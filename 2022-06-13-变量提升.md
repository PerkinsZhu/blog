## 3\.调试let声明的变量
#### 3\.1主要是将上面的测试代码中：声明变量的关键字`var`改为`let`
```javascript
<script>
    a_Function()
    let a_variable = 'aehyok'
    console.log(a_variable)
    function a_Function() {
      console.log('函数a_Function执行了', a_variable);
    }
</script>
```
执行代码以后发现直接报错了，报错内容如下图所示

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/178b1fbcd07e4b788c18b73d40b00277~tplv-k3u1fbpfcp-watermark.image?)

#### 3\.2打断点调试代码

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaeb065c5b2c4416ad8286a586ee7bdc~tplv-k3u1fbpfcp-watermark.image?)
代码断点打到如截图中`第2行位置`，可以看到`let`声明的变量，存在于单独的`Script作用域`中，并且赋值为undefined。
#### 3\.3分析3.1和3.2的代码
- 通过`var`和`let`两种方式代码运行比对情况来看，`let`声明变量的方式不存在`变量提升`的情况。
- 通过3.2截图可以发现，`let`声明变量的方式，在作用域中的已经创建，并赋值为undefined,但通过查阅资料发现：
> let声明的变量，主要是因为V8虚拟机做了限制，虽然a_variable已经在内存中并且赋值为undefined，但是当你在let a_variable 之前访问a_variable时，根据ECMAScript定义，虚拟机会阻止的访问！也可以说成是形成了暂时性的死区，这是语法规定出来的。所以就会报错。


## 4\.调试let声明的变量继续执行
主要添加了一个let声明的变量，以及为其进行了赋值操作，代码如下所示
```javascript
<script>
  a_Function()
  var a_variable = 'a_aehyok'
  let aa_variable = 'aa_aehyok'
  console.log(a_variable)
  function a_Function() {
    console.log('函数a_Function执行了', a_variable);
  }
</script>
```
执行后情况截图如下

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b63bbea4b0d4903b105e504d3140eee~tplv-k3u1fbpfcp-watermark.image?)
可以发现通过var声明的变量和let(也可以使用const)声明的变量被储存在了不同的位置，之前上面说过通过var声明的变量被存放到了`变量环境`中了。那么现在我再告诉你，通过let（也可以是const）声明的变量被存放到了`词法环境`中了。

## 4、`变量环境`和`词法环境`的区别