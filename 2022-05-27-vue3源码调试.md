- https://juejin.cn/post/6997943192851054606

# 找到开源项目
    - 脚手架vite https://github.com/vitejs/vite
    - vue3.0 https://github.com/vuejs/core
    - pc ui element-plus  https://github.com/element-plus/element-plus
    - h5 ui vant https://github.com/youzan/vant

# 查看文件发现他们的大致共性
    - 管理依赖： pnpm(全部)
    - 实现仓库的monorepo: pnpm的workspace（全部）
    - typescript：使用ts进行编写代码（全部）
    - github yml: 工作流（全部）
    - Git Hook 工具：husky + lint-staged(element-plus和vant)
    - 代码规范： EditorConfig+Prettier + ESLint（除了vuejs没有使用EditorConfig）
    - 提交规范：Commitizen + Commitlint 
    - 打包工具： Rollup(vue3.0和element-plus) 、esbuild(vant和vite)
    - 单元测试： vitest（element-plus和vite）、jest(vue3.0和vant)
    - 贡献指南地址 https://github.com/vuejs/core/blob/main/.github/contributing.md 
        - 环境要求： Node.js 版本 16+，pnpm版本 7+ 
        - 同时官网安利我们使用一下install ni，具体使用说明可以查看若川大佬的文章 https://juejin.cn/post/7023910122770399269
        - git clone代码仓库以后，在根目录 可以使用pnpm i，安装整个项目的依赖
# 严格校验使用pnpm 安装依赖
- 在项目根目录下使用yarn命令的话会有提示
    ```javascript
        yarn

        // 提示如下：
        yarn install v1.22.17
        info No lockfile found.
        $ node ./scripts/preinstall.js
        This repository requires using pnpm as the package manager  for scripts to work properly.

        error Command failed with exit code 1.
        info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.
    ```
- 如果使用pnpm就不会有上述提示了，不过如果确实有要求要使用yarn命令
    ```javascript
        // 会忽略相应的前置钩子 prexxxx,和后置钩子 postxxxx。
        yarn --ignore-scripts, 
    ```
- 通过package.json中scripts脚本列表中的preinstall，做了判断处理
    ```javascript
         "preinstall": "node ./scripts/preinstall.js",
        

        // 查看scripts/preinstall.js文件
        if (!/pnpm/.test(process.env.npm_execpath || '')) {
            console.warn(
                `\u001b[33mThis repository requires using pnpm as the package manager ` +
                ` for scripts to work properly.\u001b[39m\n`
            )
            process.exit(1)
        }
    ```
    查看vite脚手架 https://github.com/vitejs/vite/blob/main/package.json，你会发现
    ```javascript
    // 一个命令行便可以限定只能使用pnpm
     "preinstall": "npx only-allow pnpm",
    ```
#  调试script/release.js
- 先到package.json中找到scripts的 release
    ```javascript
        "release": "node scripts/release.js",
    ```
- 开启调试的方式
    - 将鼠标悬浮于 `release`上，可以看到[运行脚本]和[调试脚本] 点击调试脚本即可调试，当然要提前设置断点
    - 或者可以看到`scripts`上方，会有一个调试按钮，点击选择 release即可进入调试状态
- 开启后终端有会如下显示
    ```javascript
        pnpm run release
        Debugger attached.

        > @3.2.36 release H:\github\sourceCode\core
        > node scripts/release.js

        Debugger attached.
        ? Select release type ... 
        > patch (3.2.37)
        minor (3.3.0)
        major (4.0.0)
        custom
    ```
- 文件地址 https://github.com/vuejs/core/blob/main/scripts/release.js

# release.js中引用的依赖说明

- 依赖minimist：解析命令行中的参数
    ```javascript
        // 安装依赖
        npm i minimist

        // 引入依赖
        import minimist from 'minimist'

        console.log(process.argv, 'process')
        const argv = minimist(process.argv.slice(2))

        console.log(argv, '打印参数列表')

        //通过node环境直接执行 
        node ./other/minimist.js -a aa -b bb -c cc
        // [
        // 'C:\\Program Files\\nodejs\\node.exe',
        // 'H:\\github\\2022\\zx-ts\\other\\minimist.js',
        // '-a',
        // 'aa',
        // '-b',
        // 'bb',
        // '-c',
        // 'cc'
        // ] process

        // { _: [], a: 'aa', b: 'bb', c: 'cc' } 打印参数列表

    ```
    可以发现其中process.argv的第一和第二个元素是Node可执行文件路径和被执行js文件的路径。

- chalk终端多色彩输出
    ```javascript
    npm i chalk

    import chalk from 'chalk'

    console.log(chalk.blue('打印参数列表'))
    ```
- semver 语义化版本
    详细解释 https://semver.org/lang/zh-CN/

    ```javascript
        // 举个简单的例子版本号 2.0.1
        // 版本号格式： 主版本号（major）.次版本号（minor）.修订号（patch）
        // 则 2为主版本号  0为次版本号  1为修订号
        // major: 变化意味着本地变更发生了巨大的变化（当你做了不兼容的 API 修改）
        // minor: 通常只反映了一些较大的更改（当你做了向下兼容的功能性新增）
        // patch 通常称之为补丁版本（当你做了向下兼容的问题修正）

        // 再举个简单的例子： 2.0.1-beta.1 
        // 这个就相当于先行版本号

        //release.js中涉及到的api
        
        //验证版本号
        console.log(semver.valid('0.0.3'), 'valid验证版本号')   // 0.0.3 ✔
        console.log(semver.valid('0.0.3-beta.1'), 'valid验证版本号')   // 0.0.3-beta.1 ✔
        console.log(semver.valid('0.0.3.44'),'验证版本号0.0.3.44')  // null ❌

        // 获取先行版本号后的标识和版本号
        console.log(semver.prerelease('0.0.3-beta.1'), 'prerelease1')  // beta  1 ✔
        console.log(semver.prerelease('1.0.0-alpha+001'), 'prerelease2')  // alpha ❌
        console.log(semver.prerelease('1.0.0-beta+exp.sha.5114f85'), 'prerelease3')   // beta❌
        console.log(semver.prerelease('1.0.0+b11111'), 'prerelease4')  // null  错误❌

        // 现有版本号为0.0.3,通过inc获取新的版本号
        console.log(semver.inc(currentVersion, 'major'), 'inc-major')  // 1.0.0
        console.log(semver.inc(currentVersion, 'minor'), 'inc-minor')  // 0.1.0
        console.log(semver.inc(currentVersion, 'patch'), 'inc-patch')  // 0.0.4
    ```

    ```javascript
        npm i semver
    ```
- enquirer 交互式询问CLI
    简单说就是交互式询问用户输入。
    
    ```javascript
        npm i enquirer

        import enquirer from 'enquirer'

        let tempArray = ['major(1.0.0)','minor(0.1.0)', 'patch(0.0.4)', 'customer' ]
        
        const { release } = await enquirer.prompt({
            type: 'select',
            name: 'release',
            message: 'Select release type',
            choices: tempArray
        })

        if(release === 'custom') {
            console.log(release, 'customer')
        } else {
            const targetVersion = release.match(/\((.*)\)/)[1]
            console.log(targetVersion, 'targetVersion')
        }
    ```

    执行命令后可以看到四个选项
    major(1.0.0)
    minor(0.1.0)
    patch(0.0.4)
    customer
    选择不同的选项，则根据不同的选项进行判断处理不同的逻辑

- execa 执行命令行的
    ```javascript
        import { execa } from 'execa'
        import {$} from 'zx'

        const arr = ['aaa', 'bbbb']
        const { stdout } = await execa('echo', arr)
        console.log(stdout, 'stdout')
        
        // 这个是通过google/zx的神器调用的命令行，我自己感觉灰常好用
        await $`echo -e  ${arr}  google/zx仓库`
    ```  

- 选择要发布的版本：
    - major
    - minor
    - patch
    - custom
- jest run 测试用例

# 
    
# 2、按照依赖
    ```javascript
        pnpm i
    ``` 
# 3、如果没有按照pnpm,先通过npm安装一下 
    ```javascript
        npm i pnpm -g
    ```
# 4、开始调试第一种方式：可以说时调试页面的

- 在package.json中的 scripts脚本 dev命令中添加，source-map是从已转换的代码，映射到原始的源文件
    - 参考 https://juejin.cn/post/6991653445161713671
        ```javascript
            "dev": "node scripts/dev.js  --sourcemap"
        ```
- 执行pnpm run dev则会build vue源码(2022年)
        ```javascript
            pnpm run dev

            //则会出现以下，代表成功了（2022年5月27日），后期vue源代码作者可能会更新，相应的提示可能发生变更，请注意一下
            > @3.2.36 dev H:\github\sourceCode\core
            > node scripts/dev.js  --sourcemap

            watching: packages\vue\dist\vue.global.js
        ```
- 调试截图查看
     ![Snipaste_2022-05-30_11-30-46.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c4acde464c4ccebabba06b8376c780~tplv-k3u1fbpfcp-watermark.image?)    
# 5、调试的第二种方式： 将光标放到scripts上的，将会出现 [运行脚本] [调试脚本]，点击调试脚本，然后在指定行号前右键选择[添加断点]即可