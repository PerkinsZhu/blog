- https://juejin.cn/post/6844903487155732494
- https://juejin.cn/post/6844903845227659271
- https://juejin.cn/post/6990232423665500167

循序渐进，我用100个正则由浅入深让小白也能入门正则表达式

## 前言
axios工具函数中有一个移除字符串首尾空格的方法，先判断是否包含trim方法，如果有直接调用trim方法进行移除，这是JavaScript自带的方法。
当然有些环境是不存trim方法的（比如IE8及以下版本是不支持trim方法的），就需要通过后面的正则进行去除首尾的空格以及特殊字符。

```javascript
//去除空格的方法涉及正则
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
```

```javascript
// 将字符串转换为CameCase 驼峰式命名
const toCamelCase = str => {
  return str.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
```

- ^ 相当于开头
- \s匹配空白字符（空格、制表符、其他空白）
`\xA0` 代表空格的意思。
在 IE 早期版本中，异步接口可能会拿到 `\uFEFF` 开头的字符串，如果不 trim 掉，会导致 JSON.parse 失败。


## 1、从最简单的正则开始

#### 1.1、匹配出单个字符
```javascript
let reg = /a/
reg.test('apple')   // true
reg.test('pear')  // true
reg.test('bed')   // false
```

#### 1.2、匹配出多个字符（或者叫字符串）
```javascript
let reg = /world/
reg.test('hello world')   // true
reg.test('good morning')  // false
```

#### 1.3、匹配某个字符串出现的次数
```javascript
let reg = /hello/igm
let str = 'hello world。 Hello, in a new world'
str.match(reg)   //(2) ['hello', 'Hello']
```

#### 1.4 替换字符串
```
let reg = /hello/igm
let str = 'hello world。 Hello, in a new world'
str.replace(reg, "aehyok")   // 替换完输出 'aehyok world。 aehyok, in a new world'
```

## 2、匹配特殊字符
```javascript
let reg = /\*/
reg.test('apple*')   // true
reg.test('pear*')  // true
reg.test('bed')   // false
```
你可以去尝试一下，如果不加这个斜杠就会报错的 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d489d2ada18a402ba7ed9e1d327c563c~tplv-k3u1fbpfcp-watermark.image?)

这里面的`*`就算是一个特殊字符，就是这个字符其实在正则表达式中存在着特殊的语义。目前在正则中有特殊意义的字符有如下几个：
`( [ { \ ^ $ | ) ] } ? * + . `。
另外这里还有一类特殊字符：
| 特殊字符 | 正则表达式 |
| ----- | ----- |
| 空白符 | \s |
| 换行符 | \n |
| 回车符 | \r |
| 制表符 | \t |
| 垂直制表符 | \v |
| 换页符 | \f |


> 空白符包括： 空格、水平制表符、垂直制表符、换行符、回车符。 `\s（小s）` 包括 [\r\n\t\f\v ])。`\S(大S)` 是[^\r\n\t\f\v]，非空白符。

使用的时候如下所示，只要有空格就可以匹配到，或者可以测试其他字符
```javascript
let reg = /\n/
reg.test('apple\n*')   // false
reg.test('apple*')   // true
```


## 3、两种模式的写法

字面量模式和字符串模式两种正则表达式的模式，最终达到的效果是一样的

#### 3.1、字面量模式
判断是否以[aehyok]开头
```javascript
// 字面量模式
let reg = /^\[aehyok\]/
reg.test('[aehyok]123')  // true
reg.test('[aeh1k]123')  // false
```
#### 3.2、字符串模式
```javascript
let reg = new RegExp('^\\[aehyok\\]')
reg.test('[aehyok]123')  // true
reg.test('[aeh1k]123')  // false
```


## 4、字符匹配的次数

#### （{m,n}）连续出现最少m次，最多n次
```javascript
let reg = /abc{2,4}d/g

reg.test("abcgg")   // false 只匹配一个c
reg.test("abccgg")   // true  能匹配两个c
reg.test("abccccgg")  //true  能匹配四个c
reg.test("abcccccgg")  ///false 超过四个c 没办法了
```

#### （?）匹配前面的子表达式出现0次或者1次,或者另外一种类型（{0,1}）

```javascript
let reg = /abcde?f/
let reg = /abcde{0,1}f/
reg.test('abcdef') // true
reg.test('abcdf') // true
reg.test('abcdeef') // false


```
第一个出现了1次
第二个出现了0次
第三个出现了2次，这个就出问题了，为false



#### （+）匹配前面的子表达式1次或多次，或者另外一种类型（{1,}）
```javascript
let reg = /[1-9][0-9]+/
let reg = /[1-9][0-9]{1,}/
reg.test("2")  // false
reg.test("2a")  // false
reg.test("21")  // true
reg.test("212")  // true
```

匹配后面的正则表达式[0-9] 一次或者多次，对于整个正则表达式来说，也可以说成是子表达式

#### （*）匹配前面的子表达式0次或多次,或者另外一种类型（{0,}）
```javascript
let reg = /[1-9]*/
let reg = /[1-9]{0,}/
reg.test("")  // true
reg.test("1")  // true
reg.test("12")  // true
```


#### 变种（{m,m}）只出现过m次
m为数字

- 四位数字
```javascript
let reg = /^[0-9]{4}$/
reg.test("1234")  // true
reg.test("12s4")  // false
reg.test("12345") // false
```


## 5、匹配位置说明

#### ^ 开头位置的说明
```javascript
// 以1234开头的字符串
let reg = /^1234/

reg.test('12345') // true
reg.test('123s5') // false
reg.test('123')  // false
```

#### $ 结尾位置的说明
```javascript
// 以1234结尾的字符串
let reg = /1234$/

reg.test('12345') // false
reg.test('111234') // true
```



- （\b） 查看字符串中是否有单词开始abc
 
```javascript
let reg = /\babc/
reg.test('hello abcdef')    // true
reg.test('hello world zabcd') // false
reg.test('hello world zdefabc') 
```

- (\b) 查看字符串中是否有单词以abc结尾的
```javascript
let reg = /abc\b/
reg.test('hello abcdef')    // false
reg.test('hello world zabcd') // false
reg.test('hello world zdefabc')   // true
```

#### 匹配单词中间部分

- (\B) 刚好是 `\b` 的反面

既不能匹配开头部分，也不能匹配结尾部分

```javascript
let reg = /\Babc/
reg.test('hello abcdef')     // false
reg.test('hello world zabcd')  // true
reg.test('hello world zdefabc')   // false
```

#### (g和m)全局模式和多行模式

- 普通模式

```javascript
let reg = /abc/
let str = "abcd abcdd   \nabcd \nabcde" 
str.match(reg)   //['abc', index: 0, input: 'abcd abcdd   \nabcd \nabcde', groups: undefined]
```

这样只会匹配出第一个

- （g）全局模式
```javascript
let reg = /abc/g
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   // ['abc', 'abc', 'abc', 'abc', 'abc']
```
全局模式下，会匹配到五个。不加全局的话，匹配到就结束匹配了，而加上全局模式，会将所有能匹配到的都匹配出来

- （m）多行模式

查看以abc开头，这里是一个字符串，并且我在中间加了两个`\n` 换行符。
```javascript
let reg = /^abc/g   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   // ['abc']
```
这样只会匹配到一个，只是一个字符串，并且以abc开头，没啥问题

现在我们再在上面的小例子中添加上m多行模式的匹配会是什么结果呢?


```javascript
let reg = /^abc/gm   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   //  ['abc', 'abc', 'abc']
```

我加入`\n` 换行符，相当于一个多行的文本，这样去执行正则的时候相当于每一行都会去单独执行正则进行匹配。
这里相当于分成了三行进行匹配

 - 组合模式 

还是上面同一个字符串，现在假如我们想匹配出四个abc，四个以abc开头的单词,不是三个 也不是五个
```javascript
let reg = /\babc/gm   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   //  ['abc', 'abc', 'abc', 'abc']
```
`\b`单词的边界控制

`m` 开启多行模式匹配

#### （i）忽略大小写
```javascript
let reg = /aBc/g
let str = "aBc  aaBc aabc"
str.match(reg) // (2) ['aBc', 'aBc']
```
没有加i标识，也就是没有开启忽略大小写的时候

下面是加i标识的匹配，通过结果可以看出匹配到三个
```javascript
let reg = /aBc/gi
let str = "aBc  aaBc aabc"
str.match(reg) // (3) ['aBc', 'aBc', 'abc']
```


## 6、多个字符匹配

#### (\d) 表示一位数字
匹配到一位数字, 等同于[0-9]
```javascript
let reg = /\d/
let reg = /[0-9]/
reg.test('1s')  // true
reg.test('ss')  // false
```

#### （\D）表示除数字意外的任意字符
匹配除数字意外的任意字符, 等同于[^0-9]
```javascript
let reg = /\D/
let reg = /[^0-9]/
reg.test('1234')  // false
reg.test('ss')  // true
```

#### (.)除了换行符以外的任何字符
```javascript
let reg = /./g
reg.test("\n")  // false 只有换行符肯定为false
reg.test("1")   // true 能匹配到不是换行符的便为true
```
#### (\w)匹配字母加数字加下划线`_`
```javascript

let reg = /[0-9a-zA-z_]{4}/
reg.test("a1b_")  // true
reg.test("a1=+")  // false
```

简化模式如下
```javascript
let reg = /\w{4}/
reg.test("a1b_")  // true
reg.test("a1=+")  // false
```
#### （\W）非单词字符下划线
匹配出四个字符
```javascript
let reg = /\W{4}/
reg.test("=-+`")  // true
reg.test("====")  // true
reg.test("____")  // false
```


## 7、贪婪匹配和懒惰匹配

#### 7、贪婪匹配
从字面意思可以简单的看出 `贪`，也就是尽可能多的匹配或者匹配到达字符串的结尾

匹配数字至少出现两位，最多出现五位
```javascript
let reg= /a.*b/;
var str = "ab a+b avb ";
str.match(regex)  // ['12', '123', '1234', '12345']
```
可以发现最后除了第一个`1`,后面的四个数字全部被匹配出来，并且直到字符串的结尾。

但是如果我们继续在字符串后面添加数字
```javascript
let reg= /\d{2,5}\s/g;
var str = "1 12  123 1234 12345 123456 1234567";
str.match(regex)  // ['12', '123', '1234', '12345', '12345', '12345', '67']
```
可以发现后面的会继续进行匹配并且进行

匹配优先又叫做 `贪婪匹配`，它的特点是，在量词作用下的表达式会尽可能尝试匹配满足条件的字符，直到后面的字符串不满足这个表达式或者到达字符串的结尾」。只有在正则表达式整体在尝试匹配却没有匹配成功的情况下，匹配优先的这部分才会「归还已经匹配的部分字符，好让整体能够匹配成功。」
https://mp.weixin.qq.com/s/AxTuXvKINhX6qLzj6Q9UJw

## 8、高阶用法

#### 8.1、（）子表达式
通过`()` 元字符所包含的正则表达式被分为一组，每个分组就是一个子表达式了。如果要发挥子表达式强大的作用，一般会结合回溯引用才会发挥其作用。

#### 8.2、回溯引用
回溯引用指的是模式的后面部分引用前面已经匹配到的子字符串。这里可以把它当做变量，类似的用法就像是 `\1`、 `\2` 以此类推。`\0`代表整个正则表达式。

```javascript
let reg = /abc/
let str = "abcd abcd d   \nab ab cd \nabcde" 
str.match(reg)  

let reg = /\b(\w)\s\1/
let str = "Hello what what is the first thing, and I am am scq000."
str.match(reg)
```


## 总结

```javascript
let reg = '/aehyok/'
```



let reg = /\b(\w+)\s\1/
let str = 'Hello what what is the first thing, and I am am scq000.'
str.match(reg)



let reg = /\b(whaa\w+)\s\1/
let str = 'Hello whaacct whaabbt is the first thing, and I am am scq000.'
str.match(reg)