## 前言
axios工具函数中有一个移除字符串首尾空格的方法，先判断是否包含trim方法，如果有直接调用trim方法进行移除，这是JavaScript自带的方法。
当然有些时候是不存trim方法的（比如IE8及以下版本是不支持trim方法的），就需要通过后面的正则进行去除首尾的空格以及特殊字符。
```javascript
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
```

- ^ 相当于开头
- \s匹配空白字符（空格、制表符、其他空白）
`\xA0` 代表空格的意思。
在 IE 早期版本中，异步接口可能会拿到 `\uFEFF` 开头的字符串，如果不 trim 掉，会导致 JSON.parse 失败。

## 匹配模式

- g 全局模式，查找字符串的全部内容，而不是找到第一个匹配的内容就结束

- 不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写


## 使用模式


## 位置

#### ^ 匹配文本的开头部分

- 判断字符串是否以aehyok开头

```javascript
let str = 'aehyok hello world'
const result = /^aehyok/.test(str)
console.log(result) // true

let str = 'aehyok hello world'
str.match('/^aehyok/')
```

匹配文本的末尾部分


## 1、先来讲几个常用的使用示例

#### 1.1判断是否为纯数字

```javascript

// {1,} // 长度至少为1
let reg = /^\d{1,}$/

reg.test("1234")  // true
reg.test("12s4")  // false

```

#### 1.2、 判断数字长度
```javascript
// 以四个数字开头，并且以四个数字结尾
let reg = /\d{4}$/
reg.test('1234') // true
reg.test('12345') // false
reg.test('123s')  // false
reg.test('123')  // false
```

#### 1.4、第一位从`abc`中任意匹配一个、第二位从`def`中任意匹配，其他任意
```javascript
let reg = /[abc][def]/

reg.test('addd')  // true
reg.test('eggg')  // false
reg.test('aggg')  // false
```


## 1、从最简单的正则开始

#### 1.1、匹配出单个字符
```javascript
let reg = /a/
reg.test('apple')   // true
reg.test('pear')  // true
reg.test('bed')   // false
```



#### 1.2、匹配出多个字符（或者叫字符串）
```javascript
let reg = /world/
reg.test('hello world')   // true
reg.test('good morning')  // false
```

#### 1.3、匹配某个字符串出现的次数
```javascript
let reg = /hello/igm
let str = 'hello world。 Hello, in a new world'
str.match(reg)   //(2) ['hello', 'Hello']
```

#### 1.4 替换字符串
```
let reg = /hello/igm
let str = 'hello world。 Hello, in a new world'
str.replace(reg, "aehyok")   // 替换完输出 'aehyok world。 aehyok, in a new world'
```

## 2、匹配特殊字符
```javascript
let reg = /\*/
reg.test('apple*')   // true
reg.test('pear*')  // true
reg.test('bed')   // false
```
你可以去尝试一下，如果不加这个斜杠就会报错的 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d489d2ada18a402ba7ed9e1d327c563c~tplv-k3u1fbpfcp-watermark.image?)

这里面的`*`就算是一个特殊字符，就是这个字符其实在正则表达式中存在着特殊的语义。目前在正则中有特殊意义的字符有如下几个：
`( [ { \ ^ $ | ) ] } ? * + . `。
另外这里还有一类特殊字符：
| 特殊字符 | 正则表达式 |
| ----- | ----- |
| 空格符 | \s |
| 换行符 | \n |
| 回车符 | \r |
| 制表符 | \t |

使用的时候如下所示，只要有空格就可以匹配到，或者可以测试其他字符
```javascript
let reg = /\n/
reg.test('apple\\n*')   // true
```


## 3、两种正则表达式的模式

字面量模式和字符串模式两种正则表达式的模式，最终达到的效果是一样的

#### 字面量模式
判断是否以[aehyok]开头
```javascript
// 字面量模式
let reg = /^\[aehyok\]/
reg.test('[aehyok]123')  // true
reg.test('[aeh1k]123')  // false
```
#### 字符串模式
```javascript
let reg = new RegExp('^\\[aehyok\\]')
reg.test('[aehyok]123')  // true
reg.test('[aeh1k]123')  // false
```

## 4、多个字符的匹配（纯数字、纯字母、等）
```javascript
let reg = /\d/
reg.test('[aehyok]123')  // true
reg.test('[aeh1k]123')  // false
```


## 匹配次数限定

## 4、匹配位置说明

#### ^ 开头位置的说明
```javascript
// 以1234开头的字符串
let reg = /^1234/

reg.test('12345') // true
reg.test('123s5') // false
reg.test('123')  // false
```

#### $ 结尾位置的说明
```javascript
// 以1234结尾的字符串
let reg = /1234$/

reg.test('12345') // false
reg.test('111234') // true
```

#### 匹配单词开始和结束(\b) 


- （\b） 查看字符串中是否有单词开始abc
 
```javascript
let reg = /\babc/
reg.test('hello abcdef')    // true
reg.test('hello world zabcd') // false
reg.test('hello world zdefabc') 
```

- (\b) 查看字符串中是否有单词以abc结尾的
```javascript
let reg = /abc\b/
reg.test('hello abcdef')    // false
reg.test('hello world zabcd') // false
reg.test('hello world zdefabc')   // true
```
#### 匹配单词中间部分

- (\B) 刚好是 `\b` 的反面

既不能匹配开头部分，也不能匹配结尾部分

```javascript
let reg = /\Babc/
reg.test('hello abcdef')     // false
reg.test('hello world zabcd')  // true
reg.test('hello world zdefabc')   // false
```

#### (g和m)全局模式和多行模式

- 普通模式

```javascript
let reg = /abc/
let str = "abcd abcdd   \nabcd \nabcde" 
str.match(reg)   //['abc', index: 0, input: 'abcd abcdd   \nabcd \nabcde', groups: undefined]
```

这样只会匹配出第一个

- （g）全局模式
```javascript
let reg = /abc/g
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   // ['abc', 'abc', 'abc', 'abc', 'abc']
```
全局模式下，会匹配到五个。不加全局的话，匹配到就结束匹配了，而加上全局模式，会将所有能匹配到的都匹配出来

- （m）多行模式

查看以abc开头，这里是一个字符串，并且我在中间加了两个`\n` 换行符。
```javascript
let reg = /^abc/g   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   // ['abc']
```
这样只会匹配到一个，只是一个字符串，并且以abc开头，没啥问题

现在我们再在上面的小例子中添加上m多行模式的匹配会是什么结果呢?


```javascript
let reg = /^abc/gm   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   //  ['abc', 'abc', 'abc']
```

我加入`\n` 换行符，相当于一个多行的文本，这样去执行正则的时候相当于每一行都会去单独执行正则进行匹配。
这里相当于分成了三行进行匹配

 - 组合模式 

还是上面同一个字符串，现在假如我们想匹配出四个abc，四个以abc开头的单词,不是三个 也不是五个
```javascript
let reg = /\babc/gm   //^表示位置，开始的位置
let str = "abcd abcdd   \nabcd \nabcde aabc" 
str.match(reg)   //  ['abc', 'abc', 'abc', 'abc']
```
`\b`单词的边界控制

`m` 开启多行模式匹配

#### （i）忽略大小写
```javascript
let reg = /aBc/g
let str = "aBc  aaBc aabc"
str.match(reg) // (2) ['aBc', 'aBc']
```
没有加i标识，也就是没有开启忽略大小写的时候

下面是加i标识的匹配，通过结果可以看出匹配到三个结果了
```javascript
let reg = /aBc/gi
let str = "aBc  aaBc aabc"
str.match(reg) // (3) ['aBc', 'aBc', 'abc']
```



## 
```javascript
// 以123开头
let reg = /^123/

reg.test('12345') // true
reg.test('123s5') // false
reg.test('123')  // false

// 以四个数字结尾
let reg = /\d{4}$/

reg.test('12345') // true
reg.test('123s5') // false
reg.test('123')  // false
```